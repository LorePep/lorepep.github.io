<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lorenzo Peppoloni</title>
    <link>/post/</link>
    <description>Recent content in Posts on Lorenzo Peppoloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 28 Feb 2020 20:13:50 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Do not write misusable APIs</title>
      <link>/interfaces/</link>
      <pubDate>Fri, 28 Feb 2020 20:13:50 +0000</pubDate>
      
      <guid>/interfaces/</guid>
      <description>APIs should be easy to use and hard to misuse.
â€” Josh Bloch
 Today I found this quote on Twitter and for a moment I thought: I&amp;rsquo;m gonna print it and frame it right now!!
This is something I see a lot in my day to day life as a Software Engineer. Spending days and days looking for nasty bugs resulting in realising that I was misusing an API, taught me that a rule to live by it&amp;rsquo;s:</description>
    </item>
    
    <item>
      <title>Re-identification with Triplet Loss</title>
      <link>/reidentification/</link>
      <pubDate>Wed, 26 Feb 2020 07:13:50 +0000</pubDate>
      
      <guid>/reidentification/</guid>
      <description>One very interesting computer vision problem is re-identification. The idea is that you have images of some entity and you want to be able to re-identify that entity in new images. As a complementary problem, you might also want to be able to say if an identity is known or not.
Classic use cases are people re-identification for surveillance, but there are also more fancy use cases such as whale re-identification for monitoring and conservation effort.</description>
    </item>
    
    <item>
      <title>Everything you need to know about multi-object tracking</title>
      <link>/mot/</link>
      <pubDate>Fri, 21 Feb 2020 07:13:50 +0000</pubDate>
      
      <guid>/mot/</guid>
      <description>I find Multiple object tracking (MOT) a very interesting problem. In the case called tracking-by-detection, you have a bunch of detections of objects (they can either be in 2D or 3D) and you have to associate detections in time figuring out if they are observation of the same object.
More formally, we can define the problem as a multi-variable estimation problem.
Given a set of frames, we have a set of states of objects in each frame.</description>
    </item>
    
    <item>
      <title>The eight-points algorithm</title>
      <link>/eightpoints/</link>
      <pubDate>Wed, 19 Feb 2020 07:13:50 +0000</pubDate>
      
      <guid>/eightpoints/</guid>
      <description>In this blog post we had a look at how to estimate the optical flow (e.g., track how pixels move in time) in a set of images. The estimation we obtained gave us pixel matches across the image set.
Given the correspondences between two images, we can estimate the motion and the 3D position of the points we are observing. Solving this problem is known as Structure from Motion (SfM).</description>
    </item>
    
    <item>
      <title>All you need to know about Learning Tests</title>
      <link>/learningtests/</link>
      <pubDate>Thu, 13 Feb 2020 07:13:50 +0000</pubDate>
      
      <guid>/learningtests/</guid>
      <description>Picture this scenario: You have to solve a new task, a new amazing coding problem, after some googling, you find a library that solve part of the problem for you. Great! You write your code using the library, you write a test&amp;hellip;and
FAIL!
You tweak the code a bit&amp;hellip;FAIL!
I think we all went through this multiple times during our developer career.
What is happening is that, you found a new library to implement a certain behaviour that you want, you think you understood the library (but you have this bugging feeling that maybe you did not), you think you know how to use it for your particular use case (but you have this bugging feeling that maybe you do not).</description>
    </item>
    
    <item>
      <title>Everything you need to know about the Lucas-Kanade tracker</title>
      <link>/lkttracker/</link>
      <pubDate>Tue, 11 Feb 2020 07:13:50 +0000</pubDate>
      
      <guid>/lkttracker/</guid>
      <description>The Lucas-Kanade-Tomasi (LKT) tracker is one of the most used trackers in computer vision. It&#39;s easy to implement and understand, it&#39;s fast to compute and it works fairly well.
The tracker is based on the Lucas-Kanade (LK) optical flow estimation algorithm. The problem of optical flow estimation is the problem of estimating the motion of the pixels in an image across a sequence of consecutive pictures (e.g., a video).
The idea of the LK estimation is pretty straightforward.</description>
    </item>
    
    <item>
      <title>Proto nested messages and repeated fields in Python</title>
      <link>/nestedmessagepy/</link>
      <pubDate>Tue, 04 Feb 2020 20:13:50 +0000</pubDate>
      
      <guid>/nestedmessagepy/</guid>
      <description>Today I was having some problems populating a proto repeated message in Python with a nested message definition, and it took me a while to figure out how to do it.
In reality it is pretty simple. Let&amp;rsquo;s make an example.
syntax = &amp;quot;proto3&amp;quot;; package test; message Trajectory2d { message Point2d { float x = 1; float y = 2; } repeated Point2d points = 1; } Let&amp;rsquo;s save our test.</description>
    </item>
    
    <item>
      <title>Table-driven tests in Python</title>
      <link>/tabledriventestspy/</link>
      <pubDate>Sun, 02 Feb 2020 02:13:50 +0000</pubDate>
      
      <guid>/tabledriventestspy/</guid>
      <description>Table-driven tests are an elegant and functional way to unittest your functions in Go. Let&amp;rsquo;s see some ideas on how to introduce this same testing pattern in Python.
What are table-driven tests One thing I really love about Go is table-driven tests. If you are not familiar with them, table-driven tests are a very elegant way to write unittests for your code. The basic idea is that you write a list of named test cases, defining the input and the expected output for each test case, then you loop over the cases, run your function and check that the actual output is equal to the expected one.</description>
    </item>
    
  </channel>
</rss>